import childProcess from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

import { ContextItem, ToolExtras } from "../..";
import { getStringArg } from "../parseArgs";
import { resolveRelativePathInDir } from "../../util/ideUtils";

const DEFAULT_JFROG_PLATFORM_URL = "https://artifactory.sdlc.ctl.gcp.db.com";
const SEVERITY_ORDER = ["Critical", "High", "Medium", "Low"] as const;

type OssVulnerabilityConfig = {
  jfrogPlatformUrl?: string;
  jfrogAccessToken?: string;
  mavenCommand?: string;
  mavenHome?: string;
};

type GroupedEntry = {
  severities: Set<string>;
  cves: Set<string>;
  fixedVersions: string[];
  vulnerableVersions: Set<string>;
  groupKey: string;
  directComponentId: string;
  dependencyStr: string;
};

class Version {
  parts: Array<number | string>;

  constructor(versionStr: string) {
    let cleaned = String(versionStr);
    cleaned = cleaned.replace(/[-.]?(final|release|ga)$/i, "");
    cleaned = cleaned.replace(/^[vV]/, "");
    const parts = cleaned.split(/[.-]/).filter((part) => part.length > 0);
    this.parts = parts.map((part) => {
      if (/^\d+$/.test(part)) {
        return Number(part);
      }
      return part.toLowerCase();
    });
  }

  compare(other: Version) {
    const minLen = Math.min(this.parts.length, other.parts.length);
    for (let i = 0; i < minLen; i += 1) {
      let left = this.parts[i];
      let right = other.parts[i];
      if (typeof left !== typeof right) {
        left = String(left);
        right = String(right);
      }
      if (typeof left === "number" && typeof right === "number") {
        if (left < right) return -1;
        if (left > right) return 1;
      } else {
        const leftStr = String(left);
        const rightStr = String(right);
        if (leftStr < rightStr) return -1;
        if (leftStr > rightStr) return 1;
      }
    }
    if (this.parts.length < other.parts.length) return -1;
    if (this.parts.length > other.parts.length) return 1;
    return 0;
  }
}

function getOssVulnerabilityConfig(config: any): OssVulnerabilityConfig {
  const ossConfig = config?.ossVulnerability;
  return {
    jfrogPlatformUrl: ossConfig?.jfrogPlatformUrl,
    jfrogAccessToken: ossConfig?.jfrogAccessToken,
    mavenCommand: ossConfig?.mavenCommand,
    mavenHome: ossConfig?.mavenHome,
  };
}

function normalizePlatformUrl(url: string) {
  return url.replace(/\/$/, "");
}

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function normalizeSeverity(value?: string) {
  if (!value) return "Unknown";
  const trimmed = value.trim().toLowerCase();
  if (trimmed.startsWith("crit")) return "Critical";
  if (trimmed.startsWith("high")) return "High";
  if (trimmed.startsWith("med")) return "Medium";
  if (trimmed.startsWith("low")) return "Low";
  return "Unknown";
}

function highestSeverity(severities: Set<string>) {
  for (const sev of SEVERITY_ORDER) {
    if (severities.has(sev)) return sev;
  }
  return "Unknown";
}

function parseCoord(componentId: string) {
  if (componentId.startsWith("gav://")) {
    const rest = componentId.slice("gav://".length);
    const parts = rest.split(":");
    if (parts.length >= 3) {
      return {
        eco: "gav",
        group: parts[0],
        artifact: parts[1],
        version: parts[2],
      };
    }
    return { eco: "gav", group: rest, artifact: rest, version: "" };
  }
  if (componentId.startsWith("npm://")) {
    const rest = componentId.slice("npm://".length);
    const idx = rest.lastIndexOf(":");
    const pkg = idx === -1 ? rest : rest.slice(0, idx);
    const ver = idx === -1 ? "" : rest.slice(idx + 1);
    return { eco: "npm", group: pkg, artifact: pkg, version: ver };
  }
  return { eco: "raw", group: componentId, artifact: componentId, version: "" };
}

function groupKeyFor(componentId: string) {
  const info = parseCoord(componentId);
  if (info.eco === "gav") return `gav://${info.group}`;
  if (info.eco === "npm") return `npm://${info.group}`;
  return `raw://${info.group}`;
}

function formatDependencyStr(componentId: string) {
  const info = parseCoord(componentId);
  if (info.eco === "gav") {
    return info.version
      ? `${info.group}:${info.artifact}:${info.version}`
      : `${info.group}:${info.artifact}`;
  }
  if (info.eco === "npm") {
    return info.version ? `${info.group}:${info.version}` : info.group;
  }
  return componentId;
}

function formatComponentLabel(entry: GroupedEntry) {
  const candidates = [
    entry.dependencyStr,
    formatDependencyStr(entry.directComponentId),
    entry.directComponentId,
    entry.groupKey,
  ];
  for (const candidate of candidates) {
    if (!candidate) continue;
    const cleaned = String(candidate).replace(/\s+/g, " ").trim();
    if (cleaned && cleaned !== "undefined" && cleaned !== "null") {
      return cleaned;
    }
  }
  return "Unknown component";
}

function cleanNpmVersion(versionStr: string) {
  return String(versionStr).replace(/^[~^>=<]*/, "").trim();
}

function resolveMavenCommand(config: OssVulnerabilityConfig) {
  const configuredCommand =
    config.mavenCommand || process.env.MAVEN_COMMAND;
  if (configuredCommand) return configuredCommand;

  const mavenHome = config.mavenHome || process.env.MAVEN_HOME;
  if (mavenHome) {
    const binDir = path.join(mavenHome, "bin");
    const candidates =
      process.platform === "win32"
        ? ["mvn.cmd", "mvn.bat", "mvn"]
        : ["mvn"];
    for (const candidate of candidates) {
      const fullPath = path.join(binDir, candidate);
      if (fs.existsSync(fullPath)) return fullPath;
    }
    return path.join(binDir, candidates[0]);
  }

  return "mvn";
}

function getNpmDependencies(
  projectDir: string,
  warnings: string[],
): string[] {
  const packageJsonPath = path.join(projectDir, "package.json");
  if (!fs.existsSync(packageJsonPath)) return [];
  try {
    const raw = fs.readFileSync(packageJsonPath, "utf-8");
    const data = JSON.parse(raw);
    const allDeps: Record<string, any> = {};
    Object.assign(allDeps, data?.dependencies || {});
    Object.assign(allDeps, data?.devDependencies || {});
    Object.assign(allDeps, data?.overrides || {});
    const components: string[] = [];
    for (const [name, version] of Object.entries(allDeps)) {
      const cleaned = cleanNpmVersion(String(version));
      if (cleaned) {
        components.push(`npm://${name}:${cleaned}`);
      }
    }
    return components;
  } catch (error) {
    warnings.push(`Failed to read package.json: ${error}`);
    return [];
  }
}

function parsePomModules(pomContent: string): string[] {
  const modules: string[] = [];
  const regex = /<module>\s*([^<]+)\s*<\/module>/gi;
  let match = regex.exec(pomContent);
  while (match) {
    const moduleName = match[1].trim();
    if (moduleName) modules.push(moduleName);
    match = regex.exec(pomContent);
  }
  return modules;
}

function parsePomPackaging(pomContent: string): string | undefined {
  const match = pomContent.match(/<packaging>\s*([^<]+)\s*<\/packaging>/i);
  return match?.[1]?.trim();
}

function getMavenDependenciesFromDir(
  projectDir: string,
  warnings: string[],
  mavenCommand: string,
): string[] {
  const pomPath = path.join(projectDir, "pom.xml");
  if (!fs.existsSync(pomPath)) return [];

  const result = childProcess.spawnSync(mavenCommand, ["dependency:tree"], {
    cwd: projectDir,
    encoding: "utf-8",
  });
  if (result.error) {
    warnings.push(
      `Maven command failed or was not found for ${projectDir}. Ensure mvn is installed and on PATH.`,
    );
    return [];
  }
  if (result.status !== 0) {
    warnings.push(`Maven dependency:tree failed for ${projectDir}.`);
    return [];
  }

  const infoPrefixPattern = /^\s*\[INFO\]\s*/;
  const treePrefixPattern = /^[|\\+\- ]+/;
  const mavenScopes = new Set([
    "compile",
    "runtime",
    "provided",
    "system",
    "test",
    "import",
    "optional",
  ]);
  const dependencies = new Set<string>();

  const stdout = result.stdout || "";
  for (const line of stdout.split(/\r?\n/)) {
    if (!infoPrefixPattern.test(line)) continue;
    const cleanedLine = line
      .replace(infoPrefixPattern, "")
      .replace(treePrefixPattern, "")
      .trim();
    if (!cleanedLine) continue;
    const fullGavString = cleanedLine.split(/\s+/)[0];
    const parts = fullGavString.split(":");
    if (parts.length < 4) continue;

    let scope = "compile";
    const last = parts[parts.length - 1]?.toLowerCase();
    if (last && mavenScopes.has(last)) {
      scope = parts.pop() || scope;
    }
    if (scope === "test") continue;

    if (parts.length === 0) continue;
    const version = parts.pop();
    if (!version || parts.length < 2) continue;
    const groupId = parts[0];
    const artifactId = parts[1];
    dependencies.add(`gav://${groupId}:${artifactId}:${version}`);
  }

  return Array.from(dependencies);
}

function getMavenDependencies(
  projectDir: string,
  warnings: string[],
  mavenCommand: string,
): string[] {
  const pomPath = path.join(projectDir, "pom.xml");
  if (!fs.existsSync(pomPath)) return [];

  let pomContent = "";
  try {
    pomContent = fs.readFileSync(pomPath, "utf-8");
  } catch (error) {
    warnings.push(`Failed to read pom.xml: ${error}`);
  }

  const rootDependencies = getMavenDependenciesFromDir(
    projectDir,
    warnings,
    mavenCommand,
  );
  const packaging = pomContent ? parsePomPackaging(pomContent) : undefined;
  const moduleNames = pomContent ? parsePomModules(pomContent) : [];

  const dependencies = new Set<string>(rootDependencies);
  if (moduleNames.length && (packaging === "pom" || !rootDependencies.length)) {
    const visited = new Set<string>([path.resolve(projectDir)]);
    const stack = moduleNames.map((moduleName) =>
      path.resolve(projectDir, moduleName),
    );
    while (stack.length) {
      const moduleDir = stack.pop();
      if (!moduleDir || visited.has(moduleDir)) continue;
      visited.add(moduleDir);
      if (!fs.existsSync(moduleDir)) continue;
      const modulePom = path.join(moduleDir, "pom.xml");
      if (!fs.existsSync(modulePom)) continue;

      const moduleDeps = getMavenDependenciesFromDir(
        moduleDir,
        warnings,
        mavenCommand,
      );
      moduleDeps.forEach((dep) => dependencies.add(dep));

      try {
        const modulePomContent = fs.readFileSync(modulePom, "utf-8");
        const modulePackaging = parsePomPackaging(modulePomContent);
        const moduleChildren = parsePomModules(modulePomContent);
        if (moduleChildren.length && modulePackaging === "pom") {
          moduleChildren.forEach((child) => {
            stack.push(path.resolve(moduleDir, child));
          });
        }
      } catch (error) {
        warnings.push(`Failed to read pom.xml for ${moduleDir}: ${error}`);
      }
    }
  }

  return Array.from(dependencies);
}

function getGradleDependencies(
  projectDir: string,
  warnings: string[],
): string[] {
  const buildGradle = path.join(projectDir, "build.gradle");
  const buildGradleKts = path.join(projectDir, "build.gradle.kts");
  if (!fs.existsSync(buildGradle) && !fs.existsSync(buildGradleKts)) {
    return [];
  }

  const gradlewName = process.platform === "win32" ? "gradlew.bat" : "gradlew";
  const gradlewPath = path.join(projectDir, gradlewName);
  const command = fs.existsSync(gradlewPath) ? gradlewPath : "gradle";
  const args = ["dependencies", "--console=plain"];

  const result = childProcess.spawnSync(command, args, {
    cwd: projectDir,
    encoding: "utf-8",
  });

  if (result.error) {
    warnings.push(
      "Gradle command failed or was not found. Ensure gradle/gradlew is installed and on PATH.",
    );
    return [];
  }
  if (result.status !== 0) {
    warnings.push("Gradle dependencies command failed.");
    return [];
  }

  const dependencies = new Set<string>();
  const linePattern =
    /(?:^|\s)---\s+([A-Za-z0-9_.-]+):([A-Za-z0-9_.-]+):([^\s]+)(?:\s+->\s+([^\s]+))?/;
  const stdout = result.stdout || "";
  for (const line of stdout.split(/\r?\n/)) {
    const match = linePattern.exec(line);
    if (!match) continue;
    const groupId = match[1];
    const artifactId = match[2];
    const rawVersion = match[4] || match[3];
    if (!rawVersion || rawVersion === "unspecified") continue;
    const version = rawVersion.replace(/\(.*\)$/, "");
    dependencies.add(`gav://${groupId}:${artifactId}:${version}`);
  }

  return Array.from(dependencies);
}

async function getScanGraph(
  extras: ToolExtras,
  baseUrl: string,
  headers: Record<string, string>,
  componentId: string,
) {
  const scanRequestUrl = `${baseUrl}/xray/api/v1/scan/graph`;
  try {
    const response = await extras.fetch(scanRequestUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({ component_id: componentId }),
    });
    if (response.status === 404) return null;
    if (!response.ok) return null;
    const scanPayload = await response.json().catch(() => null);
    const scanId = scanPayload?.scan_id;
    if (!scanId) return null;
    const scanResultUrl = `${baseUrl}/xray/api/v1/scan/graph/${scanId}?include_licenses=true&include_vulnerabilities=true`;
    for (let i = 0; i < 20; i += 1) {
      const resultResponse = await extras.fetch(scanResultUrl, { headers });
      if (resultResponse.status === 404) {
        await sleep(3000);
        continue;
      }
      if (!resultResponse.ok) return null;
      const resultData = await resultResponse.json().catch(() => null);
      if (resultData?.status === "completed") return resultData;
      await sleep(3000);
    }
    return null;
  } catch {
    return null;
  }
}

function getOrCreateGroupEntry(
  map: Map<string, GroupedEntry>,
  key: string,
  directComponentId: string,
  groupKey: string,
) {
  let entry = map.get(key);
  if (!entry) {
    entry = {
      severities: new Set<string>(),
      cves: new Set<string>(),
      fixedVersions: [],
      vulnerableVersions: new Set<string>(),
      groupKey,
      directComponentId,
      dependencyStr: formatDependencyStr(directComponentId),
    };
    map.set(key, entry);
  }
  return entry;
}

function maxVersionString(versions: string[]) {
  let best: string | null = null;
  let bestVersion: Version | null = null;
  versions.forEach((value) => {
    const version = new Version(value);
    if (!bestVersion || version.compare(bestVersion) > 0) {
      bestVersion = version;
      best = value;
    }
  });
  return best;
}

function buildReport(
  totalDependencies: number,
  groupedSummary: Map<string, GroupedEntry>,
  groupedDetails: Map<string, GroupedEntry>,
  unifiedFixByGroup: Map<string, string>,
  warnings: string[],
) {
  const summaryCounts: Record<string, number> = {
    Critical: 0,
    High: 0,
    Medium: 0,
    Low: 0,
  };

  groupedSummary.forEach((entry) => {
    const sev = highestSeverity(entry.severities);
    if (sev in summaryCounts) {
      summaryCounts[sev] += 1;
    }
  });

  const criticalItems: Array<[string, GroupedEntry]> = [];
  const highItems: Array<[string, GroupedEntry]> = [];
  groupedDetails.forEach((entry, key) => {
    if (entry.severities.has("Critical")) {
      criticalItems.push([key, entry]);
    } else if (entry.severities.has("High")) {
      highItems.push([key, entry]);
    }
  });

  const sortKey = (item: [string, GroupedEntry]) => {
    const [, entry] = item;
    return `${entry.dependencyStr}::${item[0]}`;
  };
  criticalItems.sort((a, b) => (sortKey(a) < sortKey(b) ? -1 : 1));
  highItems.sort((a, b) => (sortKey(a) < sortKey(b) ? -1 : 1));

  const lines: string[] = [];
  lines.push("## OSS Vulnerability Scan Report", "");
  lines.push(`- Total dependencies scanned: ${totalDependencies}`, "");

  lines.push("### Summary");
  lines.push(`- Critical: ${summaryCounts.Critical}`);
  lines.push(`- High: ${summaryCounts.High}`);
  lines.push(`- Medium: ${summaryCounts.Medium}`);
  lines.push(`- Low: ${summaryCounts.Low}`);

  if (warnings.length) {
    lines.push("", "### Warnings");
    warnings.forEach((warning) => {
      lines.push(`- ${warning}`);
    });
  }

  if (criticalItems.length) {
    lines.push("", "### Critical Vulnerabilities");
    criticalItems.forEach(([_, entry]) => {
      const componentLabel = formatComponentLabel(entry);
      const componentId = entry.directComponentId?.trim();
      const recFix = unifiedFixByGroup.get(entry.groupKey) || "Not specified";
      const vulnVersions =
        Array.from(entry.vulnerableVersions)
          .filter((v) => v && v !== "N/A")
          .sort()
          .join(", ") || "N/A";
      const cves =
        Array.from(entry.cves).sort().join(", ") || "N/A";
      lines.push(
        "",
        `- Component: ${componentLabel}`,
        ...(componentId && componentId !== componentLabel
          ? [`  - Component ID: \`${componentId}\``]
          : []),
        "  - Severity: Critical",
        `  - Vulnerable versions: \`${vulnVersions}\``,
        `  - Recommended fix: \`${recFix}\``,
        `  - CVEs: ${cves}`,
      );
    });
  } else {
    lines.push("", "### Critical Vulnerabilities");
    lines.push("- None");
  }

  if (highItems.length) {
    lines.push("", "### High Vulnerabilities");
    highItems.forEach(([_, entry]) => {
      const componentLabel = formatComponentLabel(entry);
      const componentId = entry.directComponentId?.trim();
      const recFix = unifiedFixByGroup.get(entry.groupKey) || "Not specified";
      const vulnVersions =
        Array.from(entry.vulnerableVersions)
          .filter((v) => v && v !== "N/A")
          .sort()
          .join(", ") || "N/A";
      const cves =
        Array.from(entry.cves).sort().join(", ") || "N/A";
      lines.push(
        "",
        `- Component: ${componentLabel}`,
        ...(componentId && componentId !== componentLabel
          ? [`  - Component ID: \`${componentId}\``]
          : []),
        "  - Severity: High",
        `  - Vulnerable versions: \`${vulnVersions}\``,
        `  - Recommended fix: \`${recFix}\``,
        `  - CVEs: ${cves}`,
      );
    });
  } else {
    lines.push("", "### High Vulnerabilities");
    lines.push("- None");
  }

  return lines.join("\n");
}

export async function ossVulnerabilityScanImpl(
  args: any,
  extras: ToolExtras,
): Promise<ContextItem[]> {
  const projectDirInput = getStringArg(args, "project_dir").trim();
  let projectDir: string;
  if (projectDirInput.startsWith("file:")) {
    projectDir = fileURLToPath(projectDirInput);
  } else if (path.isAbsolute(projectDirInput)) {
    projectDir = projectDirInput;
  } else {
    const resolvedUri = await resolveRelativePathInDir(
      projectDirInput,
      extras.ide,
    );
    if (!resolvedUri) {
      throw new Error(`Project directory not found: ${projectDirInput}`);
    }
    projectDir = resolvedUri.startsWith("file:")
      ? fileURLToPath(resolvedUri)
      : path.resolve(projectDirInput);
  }
  if (!fs.existsSync(projectDir) || !fs.statSync(projectDir).isDirectory()) {
    throw new Error(`Project directory not found: ${projectDir}`);
  }
  const hasPom = fs.existsSync(path.join(projectDir, "pom.xml"));
  const hasGradle =
    fs.existsSync(path.join(projectDir, "build.gradle")) ||
    fs.existsSync(path.join(projectDir, "build.gradle.kts"));
  const hasPackageJson = fs.existsSync(path.join(projectDir, "package.json"));
  if (!hasPom && !hasGradle && !hasPackageJson) {
    throw new Error(
      `No supported build files found in ${projectDir}. Expected pom.xml, build.gradle(.kts), or package.json.`,
    );
  }

  const config = getOssVulnerabilityConfig(extras.config);
  const jfrogAccessToken =
    config.jfrogAccessToken || process.env.JFROG_ACCESS_TOKEN;
  const jfrogPlatformUrl =
    config.jfrogPlatformUrl ||
    process.env.JFROG_PLATFORM_URL ||
    DEFAULT_JFROG_PLATFORM_URL;

  if (!jfrogAccessToken) {
    throw new Error(
      "JFROG access token is required. Set ossVulnerability.jfrogAccessToken or JFROG_ACCESS_TOKEN.",
    );
  }

  void extras.ide.showToast(
    "info",
    "OSS scan started - resolving dependencies...",
  );

  const warnings: string[] = [];
  const npmDependencies = getNpmDependencies(projectDir, warnings);
  const mavenCommand = resolveMavenCommand(config);
  const mavenDependencies = getMavenDependencies(
    projectDir,
    warnings,
    mavenCommand,
  );
  const gradleDependencies = getGradleDependencies(projectDir, warnings);
  const componentsToScan = Array.from(
    new Set([...npmDependencies, ...mavenDependencies, ...gradleDependencies]),
  ).sort();

  if (!componentsToScan.length) {
    const warningText = warnings.length
      ? `\n\nWarnings:\n${warnings.map((warning) => `- ${warning}`).join("\n")}`
      : "";
    return [
      {
        name: extras.tool.displayTitle,
        description: "Tool output",
        content: `No scannable dependencies found.${warningText}`,
        icon: extras.tool.faviconUrl,
      },
    ];
  }

  void extras.ide.showToast(
    "info",
    `Found ${componentsToScan.length} dependencies (Maven ${mavenDependencies.length} / Gradle ${gradleDependencies.length} / NPM ${npmDependencies.length}). Starting Xray scan...`,
  );

  const baseUrl = normalizePlatformUrl(jfrogPlatformUrl);
  const headers = {
    Authorization: `Bearer ${jfrogAccessToken}`,
    "Content-Type": "application/json",
  };

  const allVulnerabilities: any[] = [];
  const progressInterval = 25;
  for (let i = 0; i < componentsToScan.length; i += 1) {
    const component = componentsToScan[i];
    const scanResults = await getScanGraph(
      extras,
      baseUrl,
      headers,
      component,
    );
    const vulnerabilities = scanResults?.vulnerabilities;
    if (Array.isArray(vulnerabilities)) {
      vulnerabilities.forEach((vuln: any) => {
        vuln.scanned_component_id = scanResults?.component_id || component;
        allVulnerabilities.push(vuln);
      });
    }
    const scannedCount = i + 1;
    if (
      scannedCount === componentsToScan.length ||
      scannedCount % progressInterval === 0
    ) {
      void extras.ide.showToast(
        "info",
        `OSS scan in progress: ${scannedCount}/${componentsToScan.length} dependencies scanned...`,
      );
    }
  }

  const groupedForSummary = new Map<string, GroupedEntry>();
  const groupedHighCritDetails = new Map<string, GroupedEntry>();
  const groupIdAllFixedVersions = new Map<string, Set<string>>();

  for (const vuln of allVulnerabilities) {
    const severity = normalizeSeverity(vuln?.severity);
    const cves: string[] = Array.isArray(vuln?.cves)
      ? vuln.cves.map((cve: any) => cve?.cve || "N/A")
      : [];

    const components = vuln?.components || {};
    const directKeys = Object.keys(components);
    if (!directKeys.length) continue;

    const directComponentId = directKeys[0];
    const componentDetails = components[directComponentId] || {};
    const fixedVersions = Array.isArray(componentDetails.fixed_versions)
      ? componentDetails.fixed_versions
      : [];
    const vulnerableVersion = componentDetails.package_version || "N/A";
    const scannedComponentId =
      vuln.scanned_component_id || directComponentId;

    let groupingKey = directComponentId;
    if (directComponentId !== scannedComponentId) {
      const scannedName = scannedComponentId.includes("//")
        ? scannedComponentId.split("//")[1]
        : scannedComponentId;
      groupingKey = `${directComponentId} (transitive via ${scannedName})`;
    }

    const groupKey = groupKeyFor(directComponentId);
    if (!groupIdAllFixedVersions.has(groupKey)) {
      groupIdAllFixedVersions.set(groupKey, new Set<string>());
    }
    const fixedSet = groupIdAllFixedVersions.get(groupKey) as Set<string>;
    fixedVersions.forEach((version: any) => {
      if (typeof version === "string" && /\d/.test(version)) {
        fixedSet.add(version);
      }
    });

    const summaryEntry = getOrCreateGroupEntry(
      groupedForSummary,
      groupingKey,
      directComponentId,
      groupKey,
    );
    summaryEntry.severities.add(severity);
    for (const cve of cves) {
      summaryEntry.cves.add(cve);
    }
    summaryEntry.fixedVersions.push(...fixedVersions);
    summaryEntry.vulnerableVersions.add(vulnerableVersion);

    if (severity === "High" || severity === "Critical") {
      const detailEntry = getOrCreateGroupEntry(
        groupedHighCritDetails,
        groupingKey,
        directComponentId,
        groupKey,
      );
      detailEntry.severities.add(severity);
      for (const cve of cves) {
        detailEntry.cves.add(cve);
      }
      detailEntry.fixedVersions.push(...fixedVersions);
      detailEntry.vulnerableVersions.add(vulnerableVersion);
    }
  }

  const unifiedFixByGroup = new Map<string, string>();
  groupIdAllFixedVersions.forEach((versions, groupKey) => {
    const valid = Array.from(versions).filter(
      (version) => version && /\d/.test(version),
    );
    if (valid.length) {
      const maxVersion = maxVersionString(valid);
      unifiedFixByGroup.set(groupKey, maxVersion || "Not specified");
    } else {
      unifiedFixByGroup.set(groupKey, "Not specified");
    }
  });

  const report = buildReport(
    componentsToScan.length,
    groupedForSummary,
    groupedHighCritDetails,
    unifiedFixByGroup,
    warnings,
  );

  void extras.ide.showToast(
    "info",
    `OSS scan complete - scanned ${componentsToScan.length} dependencies.`,
  );

  return [
    {
      name: extras.tool.displayTitle,
      description: "Tool output",
      content: report,
      icon: extras.tool.faviconUrl,
    },
  ];
}
